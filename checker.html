<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Link Block Checker</title>
  <style>
    body { font-family: sans-serif; padding: 20px; background: #f0f0f0; }
    h1 { margin-bottom: 10px; }
    input[type="file"] { margin-bottom: 20px; }
    table { width: 100%; border-collapse: collapse; margin-top: 10px; }
    th, td { padding: 8px; border: 1px solid #ccc; text-align: left; }
    th { background: #ddd; }
    .working { background: #d4edda; }
    .blocked { background: #f8d7da; }
    .timeout { background: #fff3cd; }
  </style>
</head>
<body>
  <h1>ðŸ§ª Link Block Checker (with CSV support)</h1>
  <p><strong>Note:</strong> V4. Retrieving the exact IP address of a remote server directly from client-side JavaScript (in a web browser) is generally not possible due to browser security restrictions (e.g., Same-Origin Policy, lack of direct DNS lookup APIs). To get the IP, you would typically need a server-side proxy or API to perform the lookup and return the IP to your browser script.</p>
  <input type="file" id="fileInput" accept=".txt,.csv">
  <table id="results">
    <thead>
      <tr><th>Link</th><th>Status</th><th>IP Address</th></tr>
    </thead>
    <tbody></tbody>
  </table>

  <script>
    const fileInput = document.getElementById("fileInput");
    const resultsTable = document.getElementById("results").querySelector("tbody");

    fileInput.addEventListener("change", async (event) => {
      const file = event.target.files[0];
      if (!file) return;

      const text = await file.text();
      let urls;

      // Check if the file is a CSV and parse accordingly
      if (file.name.endsWith('.csv')) {
        urls = text
          .split(/\r?\n/)
          .slice(1) // Skip the header row
          .map(row => {
            const columns = row.split(',');
            // Get the first column (domain name) and remove quotes
            return columns[0] ? columns[0].replace(/"/g, '').trim() : null;
          })
          .filter(url => url); // Filter out any empty or invalid rows
      } else {
        // Fallback to original .txt parsing
        urls = text.split(/\r?\n/).map(line => line.trim()).filter(line => line);
      }


      let workingRows = [];
      let otherRows = [];

      resultsTable.innerHTML = ""; // Clear previous results

      async function getIpAddress(url) {
        return 'Not directly available (Client-side)';
      }

      for (let url of urls) {
        if (!url.startsWith("http://") && !url.startsWith("https://")) {
          url = "https://" + url;
        }

        const row = document.createElement("tr");
        const linkCell = document.createElement("td");
        const statusCell = document.createElement("td");
        const ipCell = document.createElement("td");

        linkCell.innerHTML = `<a href="${url}" target="_blank">${url}</a>`;
        statusCell.textContent = "Checking...";
        ipCell.textContent = "Resolving IP...";
        row.appendChild(linkCell);
        row.appendChild(statusCell);
        row.appendChild(ipCell);

        resultsTable.appendChild(row);

        const controller = new AbortController();
        const signal = controller.signal;
        const TIMEOUT_MS = 5000;

        const timeoutId = setTimeout(() => {
          controller.abort();
        }, TIMEOUT_MS);

        let ipAddress = 'N/A';
        ipAddress = await getIpAddress(url);
        ipCell.textContent = ipAddress;

        try {
          // Use "no-cors" to check reachability without running into CORS errors
          await fetch(url, { method: "HEAD", mode: "no-cors", signal });
          clearTimeout(timeoutId);
          statusCell.textContent = "âœ… Working";
          row.className = "working";
          workingRows.unshift(row); // Add to the top of the list
        } catch (error) {
          clearTimeout(timeoutId);
          if (error.name === 'AbortError') {
            statusCell.textContent = "âš ï¸ Timed Out (5s)";
            row.className = "timeout";
          } else {
            statusCell.textContent = "âŒ Blocked or Unreachable";
            row.className = "blocked";
          }
          otherRows.push(row); // Add to the end of the list
        }

        // Re-render the table to keep working links at the top
        resultsTable.innerHTML = "";
        workingRows.forEach(r => resultsTable.appendChild(r));
        otherRows.forEach(r => resultsTable.appendChild(r));
      }
    });
  </script>
</body>
</html>
